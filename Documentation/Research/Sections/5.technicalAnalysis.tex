Now that the requirements are set, and our research question has been formulated, we know what type of features we are looking for in a technical setting. In this section we illustrate our findings, and justify our choices in terms of tools deployment, architecture design and system components.

\subsection{Why a web application?}
One of the main ideas that have been advised to us by our coach is the creation of a web application for our project. The justification for this is ease of usability and compatibility across several platforms. Web applications are also exempted from platform-specific updates, whereas now one single update on the web application immediatly reaches all of our users at once. When a web application is used, users can access the exact same content from different computers or mobile devices.

\subsection{Objective}
There are various models readily available for the implementation of a web application. The choice of a specific model usually depends on the context and objectives of the project itself. Our current project entails the development of a prototype within a time constraint of 11 to 12 weeks, which persuaded us to use a full stack framework. If we would use a full stack framework, we should be able to focus primarily on techniques that allow us to perform rapid prototyping, generate quality code and provide good documentation all of which meet the clients requirements. The following features should facilitate reaching our objectives during the development phase.

\begin{enumerate}
	\item \textbf{a Full-Stack framework}: A framework that already contains all the basic utilities to create and run an application, with the option to connect or import external entities too.
	\item \textbf{Rapid Prototyping}: Allows us to convert the clients requirements into a prototype in a fast way so it can be immediatly reviewed and refined for the next prototype.
	\item \textbf{Scalability}: The ability of a system, network, or process to handle a growing amount of work in a capable manner or its ability to be enlarged to accommodate that growth.\cite{wiki:scalability}
	\item \textbf{Reliablity}: The ability of a system to function under predefined conditions.
\end{enumerate}
\subsection{Project Development Methodology} % (fold)

For our project development methodology we chose the agile Scrum methodology. This means that we will have weekly sprints (iterations within a fixed amount of time) in which a predefined set of features are to be implemented. Each week we show our client what we achieved, and we discuss possible changes (within the requirements that have been agreed upon). The Scrum method gives developers an advantage over sequential methodologies such as the waterfall model or the V-model, because when changes have to be made to either pieces of code, features or even requirements, the sequential methodologies force the developers to revise (or even redo) everything that happened after the point where they were processed within the implementation. These sort of changes are more manageable within iterative methodologies such as Scrum. Scrum also allows developers to uncover designing constraints that may not have been obvious at the start of the implementation by giving them the opportunity to pivot after every sprint. \\
Given these advantages, the use of the Scrum method should be the most adequate for our project. When using Scrum, some roles and conventions have to be attributed, which are listed below:

\begin{enumerate}
	\item \textbf{Roles}
		\begin{itemize}
			\item Product Owner/Dev Team: Arnaud Hambenne
			\item Scrum master/Dev Team: Soheil Jahanshahi
			\item Client: TU Delft Library (Babak Dehghenpour, Nicoleta Nastase)
			\item Coach: Alberto Bacchelli
		\end{itemize}
	\item \textbf{Conventions}	
\begin{itemize}
		\item Sprint duration : One iteration per week.
		\item Sprint Planning meeting: A weekly meeting that is used to prioritise the selected features for each sprint. 
		\item Sprint reflection report: A weekly evaluation where the estimated effort is compared to the actual effort that was needed to implement the chosen features, and where possible issues are documented. The evaluation takes place at the end of each Sprint.
		\item Daily Scrum meeting: A daily meeting between the developers which takes about 15 minutes.
		\item Sprint review meeting: A weekly meeting of about 15-20 minutes with the clients, in order to receive their feedback on the implemented features.
		
\end{itemize} 
\end{enumerate}
\subsection{Architectural Model : MVC}
A design pattern is important to write re-usable and maintainable code. For the Virtual assistant application is best to divide the application into three interconnected parts to separate internal representation of information from information that is presented to users or accepted by them\cite{wiki:mvc}. Such a Design is called MVC pattern which consist of three separate parts namely Model, View and Controller.
\begin{figure}[h]
\centering
\includegraphics[scale=0.3]{./img/MVC.png}
\caption{\small{model,view and controller that are interconnected by directed edges}}
\label{mvc}
	
\end{figure}

As shown in fig \ref{mvc} , MVC will give the application power to separate the classes which are used typically in a database from the user interface; that is necessary to render the model to the user. also controller will act as a brain of the application. controller decides what the user input was and how the model needs to change as a result of that input\cite{codinghorror},controller then respond back to the user by calling resulting view.

\subsection{Choice of framework}
For choosing suitable web application framework we have conducted some  constraint for ourselves to benchmark various popular existing frameworks which is proven in production. Our first criteria was choosing a framework which is based on either Java, Scala, Javascript. With this we have narrowed down our choices to search for the suitable framework. After Analyzing popular frameworks such as \href{https://grails.org/}{Grails}, \href{https://vaadin.com/home}{Vaadin}, \href{https://www.playframework.com/}{Play!} and \href{http://projects.spring.io/spring-framework/}{Spring}. We finally selected two candidates to benchmark them. We boiled down our choices between Spring framework and Play! framework.\\
\subsubsection{Benchmarking}
 below table shows comparison of these two frameworks with constraint that we have settled:\\\\

\begin{center}
	

\begin{tabular}{ |l||l|p{6cm}|p{6cm}|  }
 \hline
 \multicolumn{4}{|c|}{\textbf{Benchmark Table}} \\
 \hline
 ~ & \textbf{Constraint} & \textbf{Play! Framework} & \textbf{Spring Framework}\\
 \hline
 1 & Development Principles & Convention over configuration, Don't repeat yourself, Test-driven development & Convention over configuration, Don't repeat yourself, Test-driven development, Domain Driven Design \\
 \hline
 2 & Design pattern & Model-View-Controller, Dependency-injection, Active-Record, DAO, Actors & Model-View-Controller, Dependency-injection, Domain-Driven-Design \\
 \hline
 3 & Operating System & Cross-Platform & Cross-Platform \\
 \hline
 4 & Programming Language & Java, Scala & Java \\
 \hline
 5 & Database & MySQL, PostgreSQL, MongoDB, Oracle, SQLite, HBase, H2-database, Resis & Microsoft-BI, MYSQL, PostgreSQL, Oracle, SQLite, IBM-DB2, JDBC-Compatible, MongoDB, Microsoft-SQL-Server, Taradata, Cassandra \\
 \hline
 6 & Database model & NoSQL, Relational, Object-Relational & Document-Oriented, Graph-Oriented, Multidimensional, NoSQL, Relational, Object-Relational, XML Database \\
 \hline
 7 & Documentation level & Excellent&Excellent \\
 \hline
 8 & Programming paradigm & OOP, Functional, Concurrency Oriented&Aspect-Oriented, OOP \\
 \hline
 9 & Cloud Platform Support & Heroku, Clever Cloud, Amazon EC2, Cloud Bee, OpenShift, digital Ocean, playframework Cloud & Open Shift, Heroku, Amazon EC2, AppHarbor, CloudBee \\
 \hline
 10 & Annotation support & YES & YES \\
 \hline
 11 & Scalability & YES & YES \\
 \hline
\end{tabular}
\end{center}

The result of Benchmarking showed that there are actually not much of a difference between these two frameworks. Finally we decided to use Play!Framework for this project.

\subsection{Play! Framework}
  \input{./Sections/5.6.play.tex}



% \begin{enumerate}
% 	\item User(Client) interaction with web(Asynchronous vs sync)
% 	\item Distributed application structure(client/server)
% 	\item Scalability is the ability of a system, network, or process to handle a growing amount of work in a capable manner or its ability to be enlarged to accommodate that growth.
% 	\item Build systems
% 	\item Databases(need more research)
% 	\item Continuous Integration
% \end{enumerate}
% \subsubsection{Synchronous Vs Asynchronous}
% \subsubsection{Server-Side Rendering Vs Client/Server}
% \subsubsection{Vertical Scalability Vs. Horizontal Scalability}
% \subsubsection{sbt Vs. Maven}
% \subsubsection{mongodb vs nosql vs mysql vs postgres}
% \subsubsection{Template}
% \subsubsection{Testing}
% \subsubsection{Jenkins}
% \subsubsection{frameworks}


